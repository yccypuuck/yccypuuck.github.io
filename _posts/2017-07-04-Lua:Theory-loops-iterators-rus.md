---
layout: post
title:  "Lua:Theory loops and iterators (rus)"
date:   2017-07-04 14:20:07 +0100
categories: lua,programming,theory,rus
---

## Циклы
В качестве оператора цикла в Lua используются операторы for, while и repeat.

### for-do-end
```
 for <переменная-счётчик> = <начало цикла>, <конец цикла>, <шаг[необязателен]> do
   [тело цикла] <цепочка действий, повторяемых для всех значений переменной-счётчика из указанного диапазона>
 end
```
По умолчанию шаг = 1
```lua
 for i = 1, 10 do
   message(i)      -- Выведет числа 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
 end
```
```lua
 for i = 1, 10, 2 do
   message(i)         -- Выведет все нечётные числа 1, 3, 5, 7, 9
                      -- 11 выведено не будет, так как не попадает в заданные пределы
 end
```

### repeat–until:
```
 repeat
   <цепочка действий, которая будет выполнена хотя бы 1 раз, а если выполнится условие после until, то будет повторено>
 until <условие продолжения>
```
В условии можно ссылаться на локальные переменные, описанные внутри цикла. Цикл обязательно выполняется хотя бы 1 раз, а затем проверяется условие, необходимо ли продолжать повтор цикла.

```lua
 a = 0
 repeat
   message("Введите число > 0")
   a = input()                         -- Пользователь вводит число
 until (a < 1)                         -- Повторяем, если введено не положительное число
```

### while-do-end 
Основное отличие от прошлого цикла в том, что условие стоит в начале цикла, на входе в него. То есть сначала проверяется, нужно ли выполнять цикл, а затем происходит выполнение и, если условие всё ещё выполняется, цикл повторяется.
```
 while <условие> do
   <цепочка действий, которая может быть не выполнена ни разу, выполняется, только если выполнено условие выше>
 end
```
Аналогия цикла for:
```
 local <переменная-счётчик>=<начало цикла>
 while <переменная-счётчик> < <конец цикла> do
   <тело цикла>
   <переменная-счётчик> = <переменная-счётчик> + 1
 end
```
### break
Выйти из цикла можно с помощью оператора break.
```lua
 a = 0
 repeat
   message("Введите число")
   a = input()                         -- Пользователь вводит число
   if a == 0 then
     break                             -- Если введён 0, то выходим
   end
   message(a)
 until true                            -- Это означает правду, то есть цикл будет выполняться всегда, если его не остановить
```
В данном примере при вводе чисел они будут отображаться обратно. Но если вводится 0, то программа завершается. Следует отметить, что тут использован так называемый бесконечный цикл (его условие выполняется всегда). Это потенциально опасные конструкции, поэтому в них всегда должно быть условие остановки цикла (здесь это равенство нулю введённого числа).

## Итераторы
### Итераторы без внутреннего состояния

Итератор без внутреннего состояния не хранит никакой внутренней информации, позволяющей ему определить свое положение в итерируемом контейнере. Следующее значение управляющей переменной вычисляется непосредственно по ее предыдущему значению, а состояние используется для хранения ссылки на итерируемый контейнер. Вот пример простого итератора без внутреннего состояния:
```lua
function iter( a, i )
  i = i + 1
  local v = a[i]
  if v then
    return i, v
  else
    return nil
  end
end

function ipairs( a )
  return iter, a, 0
end
```
###Итераторы, хранящие состояние в замыкании

Если итератору для обхода контейнера необходимо внутреннее состояние, то проще всего хранить его в замыкании, создаваемом по контексту функции-фабрики. Вот простой пример:
```lua
function ipairs( a )
  local i = 0
  local t = a

  local function iter()
    i = i + 1
    local v = t[i]
    if v then
      return i, v
    else
      return nil
    end
  end

  return iter
end
```
Здесь итератор хранит весь контекст в замыкании и не нуждается в состоянии и текущем значении управляющей переменной. Соответственно, итератор не принимает состояние и управляющую переменную, а фабрика не возвращает значение состояния и стартовое значение управляющей переменной.

### Стандартные итераторы

Чаще всего итераторы применяются для обхода элементов таблиц. Для этого существует несколько предопределенных функций-фабрик итераторов. Фабрика ```pairs(t)``` возвращает итератор, дающий на каждом шаге индекс в таблице и размещенное по этому индексу значение:
```lua
for idx, val in pairs(tbl) do
  ...
end
```
На самом деле этот итератор легко определить, используя стандартную функцию next(tbl, idx):
```lua
function pairs(tbl)
  return next, tbl, nil
end
```
Функция ```next(tbl, idx)``` возвращает следующее за idx значение индекса при некотором обходе таблицы tbl (вызов ```next(tbl, nil)``` возвращает начальное значение индекса; после исчерпания элементов таблицы возвращается nil).

Фабрика ```ipairs(tbl)``` возвращает итератор, работающий совершенно аналогично описанному выше, но предназначенный для обхода таблиц, проиндексированные целыми числами начиная с 1.
